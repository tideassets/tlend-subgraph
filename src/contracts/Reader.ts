// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Reader__getAccountOrdersResultValue0Struct extends ethereum.Tuple {
  get addresses(): Reader__getAccountOrdersResultValue0AddressesStruct {
    return this[0].toTuple() as Reader__getAccountOrdersResultValue0AddressesStruct;
  }

  get numbers(): Reader__getAccountOrdersResultValue0NumbersStruct {
    return this[1].toTuple() as Reader__getAccountOrdersResultValue0NumbersStruct;
  }

  get flags(): Reader__getAccountOrdersResultValue0FlagsStruct {
    return this[2].toTuple() as Reader__getAccountOrdersResultValue0FlagsStruct;
  }
}

export class Reader__getAccountOrdersResultValue0AddressesStruct extends ethereum.Tuple {
  get account(): Address {
    return this[0].toAddress();
  }

  get receiver(): Address {
    return this[1].toAddress();
  }

  get callbackContract(): Address {
    return this[2].toAddress();
  }

  get uiFeeReceiver(): Address {
    return this[3].toAddress();
  }

  get market(): Address {
    return this[4].toAddress();
  }

  get initialCollateralToken(): Address {
    return this[5].toAddress();
  }

  get swapPath(): Array<Address> {
    return this[6].toAddressArray();
  }
}

export class Reader__getAccountOrdersResultValue0NumbersStruct extends ethereum.Tuple {
  get orderType(): i32 {
    return this[0].toI32();
  }

  get decreasePositionSwapType(): i32 {
    return this[1].toI32();
  }

  get sizeDeltaUsd(): BigInt {
    return this[2].toBigInt();
  }

  get initialCollateralDeltaAmount(): BigInt {
    return this[3].toBigInt();
  }

  get triggerPrice(): BigInt {
    return this[4].toBigInt();
  }

  get acceptablePrice(): BigInt {
    return this[5].toBigInt();
  }

  get executionFee(): BigInt {
    return this[6].toBigInt();
  }

  get callbackGasLimit(): BigInt {
    return this[7].toBigInt();
  }

  get minOutputAmount(): BigInt {
    return this[8].toBigInt();
  }

  get updatedAtBlock(): BigInt {
    return this[9].toBigInt();
  }
}

export class Reader__getAccountOrdersResultValue0FlagsStruct extends ethereum.Tuple {
  get isLong(): boolean {
    return this[0].toBoolean();
  }

  get shouldUnwrapNativeToken(): boolean {
    return this[1].toBoolean();
  }

  get isFrozen(): boolean {
    return this[2].toBoolean();
  }
}

export class Reader__getAccountPositionInfoListResultValue0Struct extends ethereum.Tuple {
  get position(): Reader__getAccountPositionInfoListResultValue0PositionStruct {
    return this[0].toTuple() as Reader__getAccountPositionInfoListResultValue0PositionStruct;
  }

  get fees(): Reader__getAccountPositionInfoListResultValue0FeesStruct {
    return this[1].toTuple() as Reader__getAccountPositionInfoListResultValue0FeesStruct;
  }

  get executionPriceResult(): Reader__getAccountPositionInfoListResultValue0ExecutionPriceResultStruct {
    return this[2].toTuple() as Reader__getAccountPositionInfoListResultValue0ExecutionPriceResultStruct;
  }

  get basePnlUsd(): BigInt {
    return this[3].toBigInt();
  }

  get uncappedBasePnlUsd(): BigInt {
    return this[4].toBigInt();
  }

  get pnlAfterPriceImpactUsd(): BigInt {
    return this[5].toBigInt();
  }
}

export class Reader__getAccountPositionInfoListResultValue0PositionStruct extends ethereum.Tuple {
  get addresses(): Reader__getAccountPositionInfoListResultValue0PositionAddressesStruct {
    return this[0].toTuple() as Reader__getAccountPositionInfoListResultValue0PositionAddressesStruct;
  }

  get numbers(): Reader__getAccountPositionInfoListResultValue0PositionNumbersStruct {
    return this[1].toTuple() as Reader__getAccountPositionInfoListResultValue0PositionNumbersStruct;
  }

  get flags(): Reader__getAccountPositionInfoListResultValue0PositionFlagsStruct {
    return this[2].toTuple() as Reader__getAccountPositionInfoListResultValue0PositionFlagsStruct;
  }
}

export class Reader__getAccountPositionInfoListResultValue0PositionAddressesStruct extends ethereum.Tuple {
  get account(): Address {
    return this[0].toAddress();
  }

  get market(): Address {
    return this[1].toAddress();
  }

  get collateralToken(): Address {
    return this[2].toAddress();
  }
}

export class Reader__getAccountPositionInfoListResultValue0PositionNumbersStruct extends ethereum.Tuple {
  get sizeInUsd(): BigInt {
    return this[0].toBigInt();
  }

  get sizeInTokens(): BigInt {
    return this[1].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[2].toBigInt();
  }

  get borrowingFactor(): BigInt {
    return this[3].toBigInt();
  }

  get fundingFeeAmountPerSize(): BigInt {
    return this[4].toBigInt();
  }

  get longTokenClaimableFundingAmountPerSize(): BigInt {
    return this[5].toBigInt();
  }

  get shortTokenClaimableFundingAmountPerSize(): BigInt {
    return this[6].toBigInt();
  }

  get increasedAtBlock(): BigInt {
    return this[7].toBigInt();
  }

  get decreasedAtBlock(): BigInt {
    return this[8].toBigInt();
  }
}

export class Reader__getAccountPositionInfoListResultValue0PositionFlagsStruct extends ethereum.Tuple {
  get isLong(): boolean {
    return this[0].toBoolean();
  }
}

export class Reader__getAccountPositionInfoListResultValue0FeesStruct extends ethereum.Tuple {
  get referral(): Reader__getAccountPositionInfoListResultValue0FeesReferralStruct {
    return this[0].toTuple() as Reader__getAccountPositionInfoListResultValue0FeesReferralStruct;
  }

  get funding(): Reader__getAccountPositionInfoListResultValue0FeesFundingStruct {
    return this[1].toTuple() as Reader__getAccountPositionInfoListResultValue0FeesFundingStruct;
  }

  get borrowing(): Reader__getAccountPositionInfoListResultValue0FeesBorrowingStruct {
    return this[2].toTuple() as Reader__getAccountPositionInfoListResultValue0FeesBorrowingStruct;
  }

  get ui(): Reader__getAccountPositionInfoListResultValue0FeesUiStruct {
    return this[3].toTuple() as Reader__getAccountPositionInfoListResultValue0FeesUiStruct;
  }

  get collateralTokenPrice(): Reader__getAccountPositionInfoListResultValue0FeesCollateralTokenPriceStruct {
    return this[4].toTuple() as Reader__getAccountPositionInfoListResultValue0FeesCollateralTokenPriceStruct;
  }

  get positionFeeFactor(): BigInt {
    return this[5].toBigInt();
  }

  get protocolFeeAmount(): BigInt {
    return this[6].toBigInt();
  }

  get positionFeeReceiverFactor(): BigInt {
    return this[7].toBigInt();
  }

  get feeReceiverAmount(): BigInt {
    return this[8].toBigInt();
  }

  get feeAmountForPool(): BigInt {
    return this[9].toBigInt();
  }

  get positionFeeAmountForPool(): BigInt {
    return this[10].toBigInt();
  }

  get positionFeeAmount(): BigInt {
    return this[11].toBigInt();
  }

  get totalCostAmountExcludingFunding(): BigInt {
    return this[12].toBigInt();
  }

  get totalCostAmount(): BigInt {
    return this[13].toBigInt();
  }
}

export class Reader__getAccountPositionInfoListResultValue0FeesReferralStruct extends ethereum.Tuple {
  get referralCode(): Bytes {
    return this[0].toBytes();
  }

  get affiliate(): Address {
    return this[1].toAddress();
  }

  get trader(): Address {
    return this[2].toAddress();
  }

  get totalRebateFactor(): BigInt {
    return this[3].toBigInt();
  }

  get traderDiscountFactor(): BigInt {
    return this[4].toBigInt();
  }

  get totalRebateAmount(): BigInt {
    return this[5].toBigInt();
  }

  get traderDiscountAmount(): BigInt {
    return this[6].toBigInt();
  }

  get affiliateRewardAmount(): BigInt {
    return this[7].toBigInt();
  }
}

export class Reader__getAccountPositionInfoListResultValue0FeesFundingStruct extends ethereum.Tuple {
  get fundingFeeAmount(): BigInt {
    return this[0].toBigInt();
  }

  get claimableLongTokenAmount(): BigInt {
    return this[1].toBigInt();
  }

  get claimableShortTokenAmount(): BigInt {
    return this[2].toBigInt();
  }

  get latestFundingFeeAmountPerSize(): BigInt {
    return this[3].toBigInt();
  }

  get latestLongTokenClaimableFundingAmountPerSize(): BigInt {
    return this[4].toBigInt();
  }

  get latestShortTokenClaimableFundingAmountPerSize(): BigInt {
    return this[5].toBigInt();
  }
}

export class Reader__getAccountPositionInfoListResultValue0FeesBorrowingStruct extends ethereum.Tuple {
  get borrowingFeeUsd(): BigInt {
    return this[0].toBigInt();
  }

  get borrowingFeeAmount(): BigInt {
    return this[1].toBigInt();
  }

  get borrowingFeeReceiverFactor(): BigInt {
    return this[2].toBigInt();
  }

  get borrowingFeeAmountForFeeReceiver(): BigInt {
    return this[3].toBigInt();
  }
}

export class Reader__getAccountPositionInfoListResultValue0FeesUiStruct extends ethereum.Tuple {
  get uiFeeReceiver(): Address {
    return this[0].toAddress();
  }

  get uiFeeReceiverFactor(): BigInt {
    return this[1].toBigInt();
  }

  get uiFeeAmount(): BigInt {
    return this[2].toBigInt();
  }
}

export class Reader__getAccountPositionInfoListResultValue0FeesCollateralTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getAccountPositionInfoListResultValue0ExecutionPriceResultStruct extends ethereum.Tuple {
  get priceImpactUsd(): BigInt {
    return this[0].toBigInt();
  }

  get priceImpactDiffUsd(): BigInt {
    return this[1].toBigInt();
  }

  get executionPrice(): BigInt {
    return this[2].toBigInt();
  }
}

export class Reader__getAccountPositionInfoListInputPricesStruct extends ethereum.Tuple {
  get indexTokenPrice(): Reader__getAccountPositionInfoListInputPricesIndexTokenPriceStruct {
    return this[0].toTuple() as Reader__getAccountPositionInfoListInputPricesIndexTokenPriceStruct;
  }

  get longTokenPrice(): Reader__getAccountPositionInfoListInputPricesLongTokenPriceStruct {
    return this[1].toTuple() as Reader__getAccountPositionInfoListInputPricesLongTokenPriceStruct;
  }

  get shortTokenPrice(): Reader__getAccountPositionInfoListInputPricesShortTokenPriceStruct {
    return this[2].toTuple() as Reader__getAccountPositionInfoListInputPricesShortTokenPriceStruct;
  }
}

export class Reader__getAccountPositionInfoListInputPricesIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getAccountPositionInfoListInputPricesLongTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getAccountPositionInfoListInputPricesShortTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getAccountPositionsResultValue0Struct extends ethereum.Tuple {
  get addresses(): Reader__getAccountPositionsResultValue0AddressesStruct {
    return this[0].toTuple() as Reader__getAccountPositionsResultValue0AddressesStruct;
  }

  get numbers(): Reader__getAccountPositionsResultValue0NumbersStruct {
    return this[1].toTuple() as Reader__getAccountPositionsResultValue0NumbersStruct;
  }

  get flags(): Reader__getAccountPositionsResultValue0FlagsStruct {
    return this[2].toTuple() as Reader__getAccountPositionsResultValue0FlagsStruct;
  }
}

export class Reader__getAccountPositionsResultValue0AddressesStruct extends ethereum.Tuple {
  get account(): Address {
    return this[0].toAddress();
  }

  get market(): Address {
    return this[1].toAddress();
  }

  get collateralToken(): Address {
    return this[2].toAddress();
  }
}

export class Reader__getAccountPositionsResultValue0NumbersStruct extends ethereum.Tuple {
  get sizeInUsd(): BigInt {
    return this[0].toBigInt();
  }

  get sizeInTokens(): BigInt {
    return this[1].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[2].toBigInt();
  }

  get borrowingFactor(): BigInt {
    return this[3].toBigInt();
  }

  get fundingFeeAmountPerSize(): BigInt {
    return this[4].toBigInt();
  }

  get longTokenClaimableFundingAmountPerSize(): BigInt {
    return this[5].toBigInt();
  }

  get shortTokenClaimableFundingAmountPerSize(): BigInt {
    return this[6].toBigInt();
  }

  get increasedAtBlock(): BigInt {
    return this[7].toBigInt();
  }

  get decreasedAtBlock(): BigInt {
    return this[8].toBigInt();
  }
}

export class Reader__getAccountPositionsResultValue0FlagsStruct extends ethereum.Tuple {
  get isLong(): boolean {
    return this[0].toBoolean();
  }
}

export class Reader__getAdlStateResult {
  value0: BigInt;
  value1: boolean;
  value2: BigInt;
  value3: BigInt;

  constructor(value0: BigInt, value1: boolean, value2: BigInt, value3: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromBoolean(this.value1));
    map.set("value2", ethereum.Value.fromSignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    return map;
  }
}

export class Reader__getAdlStateInputPricesStruct extends ethereum.Tuple {
  get indexTokenPrice(): Reader__getAdlStateInputPricesIndexTokenPriceStruct {
    return this[0].toTuple() as Reader__getAdlStateInputPricesIndexTokenPriceStruct;
  }

  get longTokenPrice(): Reader__getAdlStateInputPricesLongTokenPriceStruct {
    return this[1].toTuple() as Reader__getAdlStateInputPricesLongTokenPriceStruct;
  }

  get shortTokenPrice(): Reader__getAdlStateInputPricesShortTokenPriceStruct {
    return this[2].toTuple() as Reader__getAdlStateInputPricesShortTokenPriceStruct;
  }
}

export class Reader__getAdlStateInputPricesIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getAdlStateInputPricesLongTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getAdlStateInputPricesShortTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getDepositResultValue0Struct extends ethereum.Tuple {
  get addresses(): Reader__getDepositResultValue0AddressesStruct {
    return this[0].toTuple() as Reader__getDepositResultValue0AddressesStruct;
  }

  get numbers(): Reader__getDepositResultValue0NumbersStruct {
    return this[1].toTuple() as Reader__getDepositResultValue0NumbersStruct;
  }

  get flags(): Reader__getDepositResultValue0FlagsStruct {
    return this[2].toTuple() as Reader__getDepositResultValue0FlagsStruct;
  }
}

export class Reader__getDepositResultValue0AddressesStruct extends ethereum.Tuple {
  get account(): Address {
    return this[0].toAddress();
  }

  get receiver(): Address {
    return this[1].toAddress();
  }

  get callbackContract(): Address {
    return this[2].toAddress();
  }

  get uiFeeReceiver(): Address {
    return this[3].toAddress();
  }

  get market(): Address {
    return this[4].toAddress();
  }

  get initialLongToken(): Address {
    return this[5].toAddress();
  }

  get initialShortToken(): Address {
    return this[6].toAddress();
  }

  get longTokenSwapPath(): Array<Address> {
    return this[7].toAddressArray();
  }

  get shortTokenSwapPath(): Array<Address> {
    return this[8].toAddressArray();
  }
}

export class Reader__getDepositResultValue0NumbersStruct extends ethereum.Tuple {
  get initialLongTokenAmount(): BigInt {
    return this[0].toBigInt();
  }

  get initialShortTokenAmount(): BigInt {
    return this[1].toBigInt();
  }

  get minMarketTokens(): BigInt {
    return this[2].toBigInt();
  }

  get updatedAtBlock(): BigInt {
    return this[3].toBigInt();
  }

  get executionFee(): BigInt {
    return this[4].toBigInt();
  }

  get callbackGasLimit(): BigInt {
    return this[5].toBigInt();
  }
}

export class Reader__getDepositResultValue0FlagsStruct extends ethereum.Tuple {
  get shouldUnwrapNativeToken(): boolean {
    return this[0].toBoolean();
  }
}

export class Reader__getDepositAmountOutInputMarketStruct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getDepositAmountOutInputPricesStruct extends ethereum.Tuple {
  get indexTokenPrice(): Reader__getDepositAmountOutInputPricesIndexTokenPriceStruct {
    return this[0].toTuple() as Reader__getDepositAmountOutInputPricesIndexTokenPriceStruct;
  }

  get longTokenPrice(): Reader__getDepositAmountOutInputPricesLongTokenPriceStruct {
    return this[1].toTuple() as Reader__getDepositAmountOutInputPricesLongTokenPriceStruct;
  }

  get shortTokenPrice(): Reader__getDepositAmountOutInputPricesShortTokenPriceStruct {
    return this[2].toTuple() as Reader__getDepositAmountOutInputPricesShortTokenPriceStruct;
  }
}

export class Reader__getDepositAmountOutInputPricesIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getDepositAmountOutInputPricesLongTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getDepositAmountOutInputPricesShortTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getExecutionPriceResultValue0Struct extends ethereum.Tuple {
  get priceImpactUsd(): BigInt {
    return this[0].toBigInt();
  }

  get priceImpactDiffUsd(): BigInt {
    return this[1].toBigInt();
  }

  get executionPrice(): BigInt {
    return this[2].toBigInt();
  }
}

export class Reader__getExecutionPriceInputIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketResultValue0Struct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getMarketBySaltResultValue0Struct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getMarketInfoResultValue0Struct extends ethereum.Tuple {
  get market(): Reader__getMarketInfoResultValue0MarketStruct {
    return this[0].toTuple() as Reader__getMarketInfoResultValue0MarketStruct;
  }

  get borrowingFactorPerSecondForLongs(): BigInt {
    return this[1].toBigInt();
  }

  get borrowingFactorPerSecondForShorts(): BigInt {
    return this[2].toBigInt();
  }

  get baseFunding(): Reader__getMarketInfoResultValue0BaseFundingStruct {
    return this[3].toTuple() as Reader__getMarketInfoResultValue0BaseFundingStruct;
  }

  get nextFunding(): Reader__getMarketInfoResultValue0NextFundingStruct {
    return this[4].toTuple() as Reader__getMarketInfoResultValue0NextFundingStruct;
  }

  get virtualInventory(): Reader__getMarketInfoResultValue0VirtualInventoryStruct {
    return this[5].toTuple() as Reader__getMarketInfoResultValue0VirtualInventoryStruct;
  }

  get isDisabled(): boolean {
    return this[6].toBoolean();
  }
}

export class Reader__getMarketInfoResultValue0MarketStruct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getMarketInfoResultValue0BaseFundingStruct extends ethereum.Tuple {
  get fundingFeeAmountPerSize(): Reader__getMarketInfoResultValue0BaseFundingFundingFeeAmountPerSizeStruct {
    return this[0].toTuple() as Reader__getMarketInfoResultValue0BaseFundingFundingFeeAmountPerSizeStruct;
  }

  get claimableFundingAmountPerSize(): Reader__getMarketInfoResultValue0BaseFundingClaimableFundingAmountPerSizeStruct {
    return this[1].toTuple() as Reader__getMarketInfoResultValue0BaseFundingClaimableFundingAmountPerSizeStruct;
  }
}

export class Reader__getMarketInfoResultValue0BaseFundingFundingFeeAmountPerSizeStruct extends ethereum.Tuple {
  get long(): Reader__getMarketInfoResultValue0BaseFundingFundingFeeAmountPerSizeLongStruct {
    return this[0].toTuple() as Reader__getMarketInfoResultValue0BaseFundingFundingFeeAmountPerSizeLongStruct;
  }

  get short(): Reader__getMarketInfoResultValue0BaseFundingFundingFeeAmountPerSizeShortStruct {
    return this[1].toTuple() as Reader__getMarketInfoResultValue0BaseFundingFundingFeeAmountPerSizeShortStruct;
  }
}

export class Reader__getMarketInfoResultValue0BaseFundingFundingFeeAmountPerSizeLongStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoResultValue0BaseFundingFundingFeeAmountPerSizeShortStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoResultValue0BaseFundingClaimableFundingAmountPerSizeStruct extends ethereum.Tuple {
  get long(): Reader__getMarketInfoResultValue0BaseFundingClaimableFundingAmountPerSizeLongStruct {
    return this[0].toTuple() as Reader__getMarketInfoResultValue0BaseFundingClaimableFundingAmountPerSizeLongStruct;
  }

  get short(): Reader__getMarketInfoResultValue0BaseFundingClaimableFundingAmountPerSizeShortStruct {
    return this[1].toTuple() as Reader__getMarketInfoResultValue0BaseFundingClaimableFundingAmountPerSizeShortStruct;
  }
}

export class Reader__getMarketInfoResultValue0BaseFundingClaimableFundingAmountPerSizeLongStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoResultValue0BaseFundingClaimableFundingAmountPerSizeShortStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoResultValue0NextFundingStruct extends ethereum.Tuple {
  get longsPayShorts(): boolean {
    return this[0].toBoolean();
  }

  get fundingFactorPerSecond(): BigInt {
    return this[1].toBigInt();
  }

  get nextSavedFundingFactorPerSecond(): BigInt {
    return this[2].toBigInt();
  }

  get fundingFeeAmountPerSizeDelta(): Reader__getMarketInfoResultValue0NextFundingFundingFeeAmountPerSizeDeltaStruct {
    return this[3].toTuple() as Reader__getMarketInfoResultValue0NextFundingFundingFeeAmountPerSizeDeltaStruct;
  }

  get claimableFundingAmountPerSizeDelta(): Reader__getMarketInfoResultValue0NextFundingClaimableFundingAmountPerSizeDeltaStruct {
    return this[4].toTuple() as Reader__getMarketInfoResultValue0NextFundingClaimableFundingAmountPerSizeDeltaStruct;
  }
}

export class Reader__getMarketInfoResultValue0NextFundingFundingFeeAmountPerSizeDeltaStruct extends ethereum.Tuple {
  get long(): Reader__getMarketInfoResultValue0NextFundingFundingFeeAmountPerSizeDeltaLongStruct {
    return this[0].toTuple() as Reader__getMarketInfoResultValue0NextFundingFundingFeeAmountPerSizeDeltaLongStruct;
  }

  get short(): Reader__getMarketInfoResultValue0NextFundingFundingFeeAmountPerSizeDeltaShortStruct {
    return this[1].toTuple() as Reader__getMarketInfoResultValue0NextFundingFundingFeeAmountPerSizeDeltaShortStruct;
  }
}

export class Reader__getMarketInfoResultValue0NextFundingFundingFeeAmountPerSizeDeltaLongStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoResultValue0NextFundingFundingFeeAmountPerSizeDeltaShortStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoResultValue0NextFundingClaimableFundingAmountPerSizeDeltaStruct extends ethereum.Tuple {
  get long(): Reader__getMarketInfoResultValue0NextFundingClaimableFundingAmountPerSizeDeltaLongStruct {
    return this[0].toTuple() as Reader__getMarketInfoResultValue0NextFundingClaimableFundingAmountPerSizeDeltaLongStruct;
  }

  get short(): Reader__getMarketInfoResultValue0NextFundingClaimableFundingAmountPerSizeDeltaShortStruct {
    return this[1].toTuple() as Reader__getMarketInfoResultValue0NextFundingClaimableFundingAmountPerSizeDeltaShortStruct;
  }
}

export class Reader__getMarketInfoResultValue0NextFundingClaimableFundingAmountPerSizeDeltaLongStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoResultValue0NextFundingClaimableFundingAmountPerSizeDeltaShortStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoResultValue0VirtualInventoryStruct extends ethereum.Tuple {
  get virtualPoolAmountForLongToken(): BigInt {
    return this[0].toBigInt();
  }

  get virtualPoolAmountForShortToken(): BigInt {
    return this[1].toBigInt();
  }

  get virtualInventoryForPositions(): BigInt {
    return this[2].toBigInt();
  }
}

export class Reader__getMarketInfoInputPricesStruct extends ethereum.Tuple {
  get indexTokenPrice(): Reader__getMarketInfoInputPricesIndexTokenPriceStruct {
    return this[0].toTuple() as Reader__getMarketInfoInputPricesIndexTokenPriceStruct;
  }

  get longTokenPrice(): Reader__getMarketInfoInputPricesLongTokenPriceStruct {
    return this[1].toTuple() as Reader__getMarketInfoInputPricesLongTokenPriceStruct;
  }

  get shortTokenPrice(): Reader__getMarketInfoInputPricesShortTokenPriceStruct {
    return this[2].toTuple() as Reader__getMarketInfoInputPricesShortTokenPriceStruct;
  }
}

export class Reader__getMarketInfoInputPricesIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoInputPricesLongTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoInputPricesShortTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoListResultValue0Struct extends ethereum.Tuple {
  get market(): Reader__getMarketInfoListResultValue0MarketStruct {
    return this[0].toTuple() as Reader__getMarketInfoListResultValue0MarketStruct;
  }

  get borrowingFactorPerSecondForLongs(): BigInt {
    return this[1].toBigInt();
  }

  get borrowingFactorPerSecondForShorts(): BigInt {
    return this[2].toBigInt();
  }

  get baseFunding(): Reader__getMarketInfoListResultValue0BaseFundingStruct {
    return this[3].toTuple() as Reader__getMarketInfoListResultValue0BaseFundingStruct;
  }

  get nextFunding(): Reader__getMarketInfoListResultValue0NextFundingStruct {
    return this[4].toTuple() as Reader__getMarketInfoListResultValue0NextFundingStruct;
  }

  get virtualInventory(): Reader__getMarketInfoListResultValue0VirtualInventoryStruct {
    return this[5].toTuple() as Reader__getMarketInfoListResultValue0VirtualInventoryStruct;
  }

  get isDisabled(): boolean {
    return this[6].toBoolean();
  }
}

export class Reader__getMarketInfoListResultValue0MarketStruct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getMarketInfoListResultValue0BaseFundingStruct extends ethereum.Tuple {
  get fundingFeeAmountPerSize(): Reader__getMarketInfoListResultValue0BaseFundingFundingFeeAmountPerSizeStruct {
    return this[0].toTuple() as Reader__getMarketInfoListResultValue0BaseFundingFundingFeeAmountPerSizeStruct;
  }

  get claimableFundingAmountPerSize(): Reader__getMarketInfoListResultValue0BaseFundingClaimableFundingAmountPerSizeStruct {
    return this[1].toTuple() as Reader__getMarketInfoListResultValue0BaseFundingClaimableFundingAmountPerSizeStruct;
  }
}

export class Reader__getMarketInfoListResultValue0BaseFundingFundingFeeAmountPerSizeStruct extends ethereum.Tuple {
  get long(): Reader__getMarketInfoListResultValue0BaseFundingFundingFeeAmountPerSizeLongStruct {
    return this[0].toTuple() as Reader__getMarketInfoListResultValue0BaseFundingFundingFeeAmountPerSizeLongStruct;
  }

  get short(): Reader__getMarketInfoListResultValue0BaseFundingFundingFeeAmountPerSizeShortStruct {
    return this[1].toTuple() as Reader__getMarketInfoListResultValue0BaseFundingFundingFeeAmountPerSizeShortStruct;
  }
}

export class Reader__getMarketInfoListResultValue0BaseFundingFundingFeeAmountPerSizeLongStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoListResultValue0BaseFundingFundingFeeAmountPerSizeShortStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoListResultValue0BaseFundingClaimableFundingAmountPerSizeStruct extends ethereum.Tuple {
  get long(): Reader__getMarketInfoListResultValue0BaseFundingClaimableFundingAmountPerSizeLongStruct {
    return this[0].toTuple() as Reader__getMarketInfoListResultValue0BaseFundingClaimableFundingAmountPerSizeLongStruct;
  }

  get short(): Reader__getMarketInfoListResultValue0BaseFundingClaimableFundingAmountPerSizeShortStruct {
    return this[1].toTuple() as Reader__getMarketInfoListResultValue0BaseFundingClaimableFundingAmountPerSizeShortStruct;
  }
}

export class Reader__getMarketInfoListResultValue0BaseFundingClaimableFundingAmountPerSizeLongStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoListResultValue0BaseFundingClaimableFundingAmountPerSizeShortStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoListResultValue0NextFundingStruct extends ethereum.Tuple {
  get longsPayShorts(): boolean {
    return this[0].toBoolean();
  }

  get fundingFactorPerSecond(): BigInt {
    return this[1].toBigInt();
  }

  get nextSavedFundingFactorPerSecond(): BigInt {
    return this[2].toBigInt();
  }

  get fundingFeeAmountPerSizeDelta(): Reader__getMarketInfoListResultValue0NextFundingFundingFeeAmountPerSizeDeltaStruct {
    return this[3].toTuple() as Reader__getMarketInfoListResultValue0NextFundingFundingFeeAmountPerSizeDeltaStruct;
  }

  get claimableFundingAmountPerSizeDelta(): Reader__getMarketInfoListResultValue0NextFundingClaimableFundingAmountPerSizeDeltaStruct {
    return this[4].toTuple() as Reader__getMarketInfoListResultValue0NextFundingClaimableFundingAmountPerSizeDeltaStruct;
  }
}

export class Reader__getMarketInfoListResultValue0NextFundingFundingFeeAmountPerSizeDeltaStruct extends ethereum.Tuple {
  get long(): Reader__getMarketInfoListResultValue0NextFundingFundingFeeAmountPerSizeDeltaLongStruct {
    return this[0].toTuple() as Reader__getMarketInfoListResultValue0NextFundingFundingFeeAmountPerSizeDeltaLongStruct;
  }

  get short(): Reader__getMarketInfoListResultValue0NextFundingFundingFeeAmountPerSizeDeltaShortStruct {
    return this[1].toTuple() as Reader__getMarketInfoListResultValue0NextFundingFundingFeeAmountPerSizeDeltaShortStruct;
  }
}

export class Reader__getMarketInfoListResultValue0NextFundingFundingFeeAmountPerSizeDeltaLongStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoListResultValue0NextFundingFundingFeeAmountPerSizeDeltaShortStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoListResultValue0NextFundingClaimableFundingAmountPerSizeDeltaStruct extends ethereum.Tuple {
  get long(): Reader__getMarketInfoListResultValue0NextFundingClaimableFundingAmountPerSizeDeltaLongStruct {
    return this[0].toTuple() as Reader__getMarketInfoListResultValue0NextFundingClaimableFundingAmountPerSizeDeltaLongStruct;
  }

  get short(): Reader__getMarketInfoListResultValue0NextFundingClaimableFundingAmountPerSizeDeltaShortStruct {
    return this[1].toTuple() as Reader__getMarketInfoListResultValue0NextFundingClaimableFundingAmountPerSizeDeltaShortStruct;
  }
}

export class Reader__getMarketInfoListResultValue0NextFundingClaimableFundingAmountPerSizeDeltaLongStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoListResultValue0NextFundingClaimableFundingAmountPerSizeDeltaShortStruct extends ethereum.Tuple {
  get longToken(): BigInt {
    return this[0].toBigInt();
  }

  get shortToken(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoListResultValue0VirtualInventoryStruct extends ethereum.Tuple {
  get virtualPoolAmountForLongToken(): BigInt {
    return this[0].toBigInt();
  }

  get virtualPoolAmountForShortToken(): BigInt {
    return this[1].toBigInt();
  }

  get virtualInventoryForPositions(): BigInt {
    return this[2].toBigInt();
  }
}

export class Reader__getMarketInfoListInputMarketPricesListStruct extends ethereum.Tuple {
  get indexTokenPrice(): Reader__getMarketInfoListInputMarketPricesListIndexTokenPriceStruct {
    return this[0].toTuple() as Reader__getMarketInfoListInputMarketPricesListIndexTokenPriceStruct;
  }

  get longTokenPrice(): Reader__getMarketInfoListInputMarketPricesListLongTokenPriceStruct {
    return this[1].toTuple() as Reader__getMarketInfoListInputMarketPricesListLongTokenPriceStruct;
  }

  get shortTokenPrice(): Reader__getMarketInfoListInputMarketPricesListShortTokenPriceStruct {
    return this[2].toTuple() as Reader__getMarketInfoListInputMarketPricesListShortTokenPriceStruct;
  }
}

export class Reader__getMarketInfoListInputMarketPricesListIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoListInputMarketPricesListLongTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketInfoListInputMarketPricesListShortTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketTokenPriceResultValue1Struct extends ethereum.Tuple {
  get poolValue(): BigInt {
    return this[0].toBigInt();
  }

  get longPnl(): BigInt {
    return this[1].toBigInt();
  }

  get shortPnl(): BigInt {
    return this[2].toBigInt();
  }

  get netPnl(): BigInt {
    return this[3].toBigInt();
  }

  get longTokenAmount(): BigInt {
    return this[4].toBigInt();
  }

  get shortTokenAmount(): BigInt {
    return this[5].toBigInt();
  }

  get longTokenUsd(): BigInt {
    return this[6].toBigInt();
  }

  get shortTokenUsd(): BigInt {
    return this[7].toBigInt();
  }

  get totalBorrowingFees(): BigInt {
    return this[8].toBigInt();
  }

  get borrowingFeePoolFactor(): BigInt {
    return this[9].toBigInt();
  }

  get impactPoolAmount(): BigInt {
    return this[10].toBigInt();
  }
}

export class Reader__getMarketTokenPriceResult {
  value0: BigInt;
  value1: Reader__getMarketTokenPriceResultValue1Struct;

  constructor(
    value0: BigInt,
    value1: Reader__getMarketTokenPriceResultValue1Struct
  ) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromSignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromTuple(this.value1));
    return map;
  }
}

export class Reader__getMarketTokenPriceInputMarketStruct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getMarketTokenPriceInputIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketTokenPriceInputLongTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketTokenPriceInputShortTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getMarketsResultValue0Struct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getNetPnlInputMarketStruct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getNetPnlInputIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getOpenInterestWithPnlInputMarketStruct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getOpenInterestWithPnlInputIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getOrderResultValue0Struct extends ethereum.Tuple {
  get addresses(): Reader__getOrderResultValue0AddressesStruct {
    return this[0].toTuple() as Reader__getOrderResultValue0AddressesStruct;
  }

  get numbers(): Reader__getOrderResultValue0NumbersStruct {
    return this[1].toTuple() as Reader__getOrderResultValue0NumbersStruct;
  }

  get flags(): Reader__getOrderResultValue0FlagsStruct {
    return this[2].toTuple() as Reader__getOrderResultValue0FlagsStruct;
  }
}

export class Reader__getOrderResultValue0AddressesStruct extends ethereum.Tuple {
  get account(): Address {
    return this[0].toAddress();
  }

  get receiver(): Address {
    return this[1].toAddress();
  }

  get callbackContract(): Address {
    return this[2].toAddress();
  }

  get uiFeeReceiver(): Address {
    return this[3].toAddress();
  }

  get market(): Address {
    return this[4].toAddress();
  }

  get initialCollateralToken(): Address {
    return this[5].toAddress();
  }

  get swapPath(): Array<Address> {
    return this[6].toAddressArray();
  }
}

export class Reader__getOrderResultValue0NumbersStruct extends ethereum.Tuple {
  get orderType(): i32 {
    return this[0].toI32();
  }

  get decreasePositionSwapType(): i32 {
    return this[1].toI32();
  }

  get sizeDeltaUsd(): BigInt {
    return this[2].toBigInt();
  }

  get initialCollateralDeltaAmount(): BigInt {
    return this[3].toBigInt();
  }

  get triggerPrice(): BigInt {
    return this[4].toBigInt();
  }

  get acceptablePrice(): BigInt {
    return this[5].toBigInt();
  }

  get executionFee(): BigInt {
    return this[6].toBigInt();
  }

  get callbackGasLimit(): BigInt {
    return this[7].toBigInt();
  }

  get minOutputAmount(): BigInt {
    return this[8].toBigInt();
  }

  get updatedAtBlock(): BigInt {
    return this[9].toBigInt();
  }
}

export class Reader__getOrderResultValue0FlagsStruct extends ethereum.Tuple {
  get isLong(): boolean {
    return this[0].toBoolean();
  }

  get shouldUnwrapNativeToken(): boolean {
    return this[1].toBoolean();
  }

  get isFrozen(): boolean {
    return this[2].toBoolean();
  }
}

export class Reader__getPnlInputMarketStruct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getPnlInputIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getPnlToPoolFactorInputPricesStruct extends ethereum.Tuple {
  get indexTokenPrice(): Reader__getPnlToPoolFactorInputPricesIndexTokenPriceStruct {
    return this[0].toTuple() as Reader__getPnlToPoolFactorInputPricesIndexTokenPriceStruct;
  }

  get longTokenPrice(): Reader__getPnlToPoolFactorInputPricesLongTokenPriceStruct {
    return this[1].toTuple() as Reader__getPnlToPoolFactorInputPricesLongTokenPriceStruct;
  }

  get shortTokenPrice(): Reader__getPnlToPoolFactorInputPricesShortTokenPriceStruct {
    return this[2].toTuple() as Reader__getPnlToPoolFactorInputPricesShortTokenPriceStruct;
  }
}

export class Reader__getPnlToPoolFactorInputPricesIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getPnlToPoolFactorInputPricesLongTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getPnlToPoolFactorInputPricesShortTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getPositionResultValue0Struct extends ethereum.Tuple {
  get addresses(): Reader__getPositionResultValue0AddressesStruct {
    return this[0].toTuple() as Reader__getPositionResultValue0AddressesStruct;
  }

  get numbers(): Reader__getPositionResultValue0NumbersStruct {
    return this[1].toTuple() as Reader__getPositionResultValue0NumbersStruct;
  }

  get flags(): Reader__getPositionResultValue0FlagsStruct {
    return this[2].toTuple() as Reader__getPositionResultValue0FlagsStruct;
  }
}

export class Reader__getPositionResultValue0AddressesStruct extends ethereum.Tuple {
  get account(): Address {
    return this[0].toAddress();
  }

  get market(): Address {
    return this[1].toAddress();
  }

  get collateralToken(): Address {
    return this[2].toAddress();
  }
}

export class Reader__getPositionResultValue0NumbersStruct extends ethereum.Tuple {
  get sizeInUsd(): BigInt {
    return this[0].toBigInt();
  }

  get sizeInTokens(): BigInt {
    return this[1].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[2].toBigInt();
  }

  get borrowingFactor(): BigInt {
    return this[3].toBigInt();
  }

  get fundingFeeAmountPerSize(): BigInt {
    return this[4].toBigInt();
  }

  get longTokenClaimableFundingAmountPerSize(): BigInt {
    return this[5].toBigInt();
  }

  get shortTokenClaimableFundingAmountPerSize(): BigInt {
    return this[6].toBigInt();
  }

  get increasedAtBlock(): BigInt {
    return this[7].toBigInt();
  }

  get decreasedAtBlock(): BigInt {
    return this[8].toBigInt();
  }
}

export class Reader__getPositionResultValue0FlagsStruct extends ethereum.Tuple {
  get isLong(): boolean {
    return this[0].toBoolean();
  }
}

export class Reader__getPositionInfoResultValue0Struct extends ethereum.Tuple {
  get position(): Reader__getPositionInfoResultValue0PositionStruct {
    return this[0].toTuple() as Reader__getPositionInfoResultValue0PositionStruct;
  }

  get fees(): Reader__getPositionInfoResultValue0FeesStruct {
    return this[1].toTuple() as Reader__getPositionInfoResultValue0FeesStruct;
  }

  get executionPriceResult(): Reader__getPositionInfoResultValue0ExecutionPriceResultStruct {
    return this[2].toTuple() as Reader__getPositionInfoResultValue0ExecutionPriceResultStruct;
  }

  get basePnlUsd(): BigInt {
    return this[3].toBigInt();
  }

  get uncappedBasePnlUsd(): BigInt {
    return this[4].toBigInt();
  }

  get pnlAfterPriceImpactUsd(): BigInt {
    return this[5].toBigInt();
  }
}

export class Reader__getPositionInfoResultValue0PositionStruct extends ethereum.Tuple {
  get addresses(): Reader__getPositionInfoResultValue0PositionAddressesStruct {
    return this[0].toTuple() as Reader__getPositionInfoResultValue0PositionAddressesStruct;
  }

  get numbers(): Reader__getPositionInfoResultValue0PositionNumbersStruct {
    return this[1].toTuple() as Reader__getPositionInfoResultValue0PositionNumbersStruct;
  }

  get flags(): Reader__getPositionInfoResultValue0PositionFlagsStruct {
    return this[2].toTuple() as Reader__getPositionInfoResultValue0PositionFlagsStruct;
  }
}

export class Reader__getPositionInfoResultValue0PositionAddressesStruct extends ethereum.Tuple {
  get account(): Address {
    return this[0].toAddress();
  }

  get market(): Address {
    return this[1].toAddress();
  }

  get collateralToken(): Address {
    return this[2].toAddress();
  }
}

export class Reader__getPositionInfoResultValue0PositionNumbersStruct extends ethereum.Tuple {
  get sizeInUsd(): BigInt {
    return this[0].toBigInt();
  }

  get sizeInTokens(): BigInt {
    return this[1].toBigInt();
  }

  get collateralAmount(): BigInt {
    return this[2].toBigInt();
  }

  get borrowingFactor(): BigInt {
    return this[3].toBigInt();
  }

  get fundingFeeAmountPerSize(): BigInt {
    return this[4].toBigInt();
  }

  get longTokenClaimableFundingAmountPerSize(): BigInt {
    return this[5].toBigInt();
  }

  get shortTokenClaimableFundingAmountPerSize(): BigInt {
    return this[6].toBigInt();
  }

  get increasedAtBlock(): BigInt {
    return this[7].toBigInt();
  }

  get decreasedAtBlock(): BigInt {
    return this[8].toBigInt();
  }
}

export class Reader__getPositionInfoResultValue0PositionFlagsStruct extends ethereum.Tuple {
  get isLong(): boolean {
    return this[0].toBoolean();
  }
}

export class Reader__getPositionInfoResultValue0FeesStruct extends ethereum.Tuple {
  get referral(): Reader__getPositionInfoResultValue0FeesReferralStruct {
    return this[0].toTuple() as Reader__getPositionInfoResultValue0FeesReferralStruct;
  }

  get funding(): Reader__getPositionInfoResultValue0FeesFundingStruct {
    return this[1].toTuple() as Reader__getPositionInfoResultValue0FeesFundingStruct;
  }

  get borrowing(): Reader__getPositionInfoResultValue0FeesBorrowingStruct {
    return this[2].toTuple() as Reader__getPositionInfoResultValue0FeesBorrowingStruct;
  }

  get ui(): Reader__getPositionInfoResultValue0FeesUiStruct {
    return this[3].toTuple() as Reader__getPositionInfoResultValue0FeesUiStruct;
  }

  get collateralTokenPrice(): Reader__getPositionInfoResultValue0FeesCollateralTokenPriceStruct {
    return this[4].toTuple() as Reader__getPositionInfoResultValue0FeesCollateralTokenPriceStruct;
  }

  get positionFeeFactor(): BigInt {
    return this[5].toBigInt();
  }

  get protocolFeeAmount(): BigInt {
    return this[6].toBigInt();
  }

  get positionFeeReceiverFactor(): BigInt {
    return this[7].toBigInt();
  }

  get feeReceiverAmount(): BigInt {
    return this[8].toBigInt();
  }

  get feeAmountForPool(): BigInt {
    return this[9].toBigInt();
  }

  get positionFeeAmountForPool(): BigInt {
    return this[10].toBigInt();
  }

  get positionFeeAmount(): BigInt {
    return this[11].toBigInt();
  }

  get totalCostAmountExcludingFunding(): BigInt {
    return this[12].toBigInt();
  }

  get totalCostAmount(): BigInt {
    return this[13].toBigInt();
  }
}

export class Reader__getPositionInfoResultValue0FeesReferralStruct extends ethereum.Tuple {
  get referralCode(): Bytes {
    return this[0].toBytes();
  }

  get affiliate(): Address {
    return this[1].toAddress();
  }

  get trader(): Address {
    return this[2].toAddress();
  }

  get totalRebateFactor(): BigInt {
    return this[3].toBigInt();
  }

  get traderDiscountFactor(): BigInt {
    return this[4].toBigInt();
  }

  get totalRebateAmount(): BigInt {
    return this[5].toBigInt();
  }

  get traderDiscountAmount(): BigInt {
    return this[6].toBigInt();
  }

  get affiliateRewardAmount(): BigInt {
    return this[7].toBigInt();
  }
}

export class Reader__getPositionInfoResultValue0FeesFundingStruct extends ethereum.Tuple {
  get fundingFeeAmount(): BigInt {
    return this[0].toBigInt();
  }

  get claimableLongTokenAmount(): BigInt {
    return this[1].toBigInt();
  }

  get claimableShortTokenAmount(): BigInt {
    return this[2].toBigInt();
  }

  get latestFundingFeeAmountPerSize(): BigInt {
    return this[3].toBigInt();
  }

  get latestLongTokenClaimableFundingAmountPerSize(): BigInt {
    return this[4].toBigInt();
  }

  get latestShortTokenClaimableFundingAmountPerSize(): BigInt {
    return this[5].toBigInt();
  }
}

export class Reader__getPositionInfoResultValue0FeesBorrowingStruct extends ethereum.Tuple {
  get borrowingFeeUsd(): BigInt {
    return this[0].toBigInt();
  }

  get borrowingFeeAmount(): BigInt {
    return this[1].toBigInt();
  }

  get borrowingFeeReceiverFactor(): BigInt {
    return this[2].toBigInt();
  }

  get borrowingFeeAmountForFeeReceiver(): BigInt {
    return this[3].toBigInt();
  }
}

export class Reader__getPositionInfoResultValue0FeesUiStruct extends ethereum.Tuple {
  get uiFeeReceiver(): Address {
    return this[0].toAddress();
  }

  get uiFeeReceiverFactor(): BigInt {
    return this[1].toBigInt();
  }

  get uiFeeAmount(): BigInt {
    return this[2].toBigInt();
  }
}

export class Reader__getPositionInfoResultValue0FeesCollateralTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getPositionInfoResultValue0ExecutionPriceResultStruct extends ethereum.Tuple {
  get priceImpactUsd(): BigInt {
    return this[0].toBigInt();
  }

  get priceImpactDiffUsd(): BigInt {
    return this[1].toBigInt();
  }

  get executionPrice(): BigInt {
    return this[2].toBigInt();
  }
}

export class Reader__getPositionInfoInputPricesStruct extends ethereum.Tuple {
  get indexTokenPrice(): Reader__getPositionInfoInputPricesIndexTokenPriceStruct {
    return this[0].toTuple() as Reader__getPositionInfoInputPricesIndexTokenPriceStruct;
  }

  get longTokenPrice(): Reader__getPositionInfoInputPricesLongTokenPriceStruct {
    return this[1].toTuple() as Reader__getPositionInfoInputPricesLongTokenPriceStruct;
  }

  get shortTokenPrice(): Reader__getPositionInfoInputPricesShortTokenPriceStruct {
    return this[2].toTuple() as Reader__getPositionInfoInputPricesShortTokenPriceStruct;
  }
}

export class Reader__getPositionInfoInputPricesIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getPositionInfoInputPricesLongTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getPositionInfoInputPricesShortTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getPositionPnlUsdResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromSignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromSignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class Reader__getPositionPnlUsdInputMarketStruct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getPositionPnlUsdInputPricesStruct extends ethereum.Tuple {
  get indexTokenPrice(): Reader__getPositionPnlUsdInputPricesIndexTokenPriceStruct {
    return this[0].toTuple() as Reader__getPositionPnlUsdInputPricesIndexTokenPriceStruct;
  }

  get longTokenPrice(): Reader__getPositionPnlUsdInputPricesLongTokenPriceStruct {
    return this[1].toTuple() as Reader__getPositionPnlUsdInputPricesLongTokenPriceStruct;
  }

  get shortTokenPrice(): Reader__getPositionPnlUsdInputPricesShortTokenPriceStruct {
    return this[2].toTuple() as Reader__getPositionPnlUsdInputPricesShortTokenPriceStruct;
  }
}

export class Reader__getPositionPnlUsdInputPricesIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getPositionPnlUsdInputPricesLongTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getPositionPnlUsdInputPricesShortTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getSwapAmountOutResultFeesStruct extends ethereum.Tuple {
  get feeReceiverAmount(): BigInt {
    return this[0].toBigInt();
  }

  get feeAmountForPool(): BigInt {
    return this[1].toBigInt();
  }

  get amountAfterFees(): BigInt {
    return this[2].toBigInt();
  }

  get uiFeeReceiver(): Address {
    return this[3].toAddress();
  }

  get uiFeeReceiverFactor(): BigInt {
    return this[4].toBigInt();
  }

  get uiFeeAmount(): BigInt {
    return this[5].toBigInt();
  }
}

export class Reader__getSwapAmountOutResult {
  value0: BigInt;
  value1: BigInt;
  value2: Reader__getSwapAmountOutResultFeesStruct;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: Reader__getSwapAmountOutResultFeesStruct
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromSignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromTuple(this.value2));
    return map;
  }
}

export class Reader__getSwapAmountOutInputMarketStruct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getSwapAmountOutInputPricesStruct extends ethereum.Tuple {
  get indexTokenPrice(): Reader__getSwapAmountOutInputPricesIndexTokenPriceStruct {
    return this[0].toTuple() as Reader__getSwapAmountOutInputPricesIndexTokenPriceStruct;
  }

  get longTokenPrice(): Reader__getSwapAmountOutInputPricesLongTokenPriceStruct {
    return this[1].toTuple() as Reader__getSwapAmountOutInputPricesLongTokenPriceStruct;
  }

  get shortTokenPrice(): Reader__getSwapAmountOutInputPricesShortTokenPriceStruct {
    return this[2].toTuple() as Reader__getSwapAmountOutInputPricesShortTokenPriceStruct;
  }
}

export class Reader__getSwapAmountOutInputPricesIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getSwapAmountOutInputPricesLongTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getSwapAmountOutInputPricesShortTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getSwapPriceImpactResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromSignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromSignedBigInt(this.value1));
    return map;
  }
}

export class Reader__getSwapPriceImpactInputTokenInPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getSwapPriceImpactInputTokenOutPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getWithdrawalResultValue0Struct extends ethereum.Tuple {
  get addresses(): Reader__getWithdrawalResultValue0AddressesStruct {
    return this[0].toTuple() as Reader__getWithdrawalResultValue0AddressesStruct;
  }

  get numbers(): Reader__getWithdrawalResultValue0NumbersStruct {
    return this[1].toTuple() as Reader__getWithdrawalResultValue0NumbersStruct;
  }

  get flags(): Reader__getWithdrawalResultValue0FlagsStruct {
    return this[2].toTuple() as Reader__getWithdrawalResultValue0FlagsStruct;
  }
}

export class Reader__getWithdrawalResultValue0AddressesStruct extends ethereum.Tuple {
  get account(): Address {
    return this[0].toAddress();
  }

  get receiver(): Address {
    return this[1].toAddress();
  }

  get callbackContract(): Address {
    return this[2].toAddress();
  }

  get uiFeeReceiver(): Address {
    return this[3].toAddress();
  }

  get market(): Address {
    return this[4].toAddress();
  }

  get longTokenSwapPath(): Array<Address> {
    return this[5].toAddressArray();
  }

  get shortTokenSwapPath(): Array<Address> {
    return this[6].toAddressArray();
  }
}

export class Reader__getWithdrawalResultValue0NumbersStruct extends ethereum.Tuple {
  get marketTokenAmount(): BigInt {
    return this[0].toBigInt();
  }

  get minLongTokenAmount(): BigInt {
    return this[1].toBigInt();
  }

  get minShortTokenAmount(): BigInt {
    return this[2].toBigInt();
  }

  get updatedAtBlock(): BigInt {
    return this[3].toBigInt();
  }

  get executionFee(): BigInt {
    return this[4].toBigInt();
  }

  get callbackGasLimit(): BigInt {
    return this[5].toBigInt();
  }
}

export class Reader__getWithdrawalResultValue0FlagsStruct extends ethereum.Tuple {
  get shouldUnwrapNativeToken(): boolean {
    return this[0].toBoolean();
  }
}

export class Reader__getWithdrawalAmountOutResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class Reader__getWithdrawalAmountOutInputMarketStruct extends ethereum.Tuple {
  get marketToken(): Address {
    return this[0].toAddress();
  }

  get indexToken(): Address {
    return this[1].toAddress();
  }

  get longToken(): Address {
    return this[2].toAddress();
  }

  get shortToken(): Address {
    return this[3].toAddress();
  }
}

export class Reader__getWithdrawalAmountOutInputPricesStruct extends ethereum.Tuple {
  get indexTokenPrice(): Reader__getWithdrawalAmountOutInputPricesIndexTokenPriceStruct {
    return this[0].toTuple() as Reader__getWithdrawalAmountOutInputPricesIndexTokenPriceStruct;
  }

  get longTokenPrice(): Reader__getWithdrawalAmountOutInputPricesLongTokenPriceStruct {
    return this[1].toTuple() as Reader__getWithdrawalAmountOutInputPricesLongTokenPriceStruct;
  }

  get shortTokenPrice(): Reader__getWithdrawalAmountOutInputPricesShortTokenPriceStruct {
    return this[2].toTuple() as Reader__getWithdrawalAmountOutInputPricesShortTokenPriceStruct;
  }
}

export class Reader__getWithdrawalAmountOutInputPricesIndexTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getWithdrawalAmountOutInputPricesLongTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader__getWithdrawalAmountOutInputPricesShortTokenPriceStruct extends ethereum.Tuple {
  get min(): BigInt {
    return this[0].toBigInt();
  }

  get max(): BigInt {
    return this[1].toBigInt();
  }
}

export class Reader extends ethereum.SmartContract {
  static bind(address: Address): Reader {
    return new Reader("Reader", address);
  }

  getAccountOrders(
    dataStore: Address,
    account: Address,
    start: BigInt,
    end: BigInt
  ): Array<Reader__getAccountOrdersResultValue0Struct> {
    let result = super.call(
      "getAccountOrders",
      "getAccountOrders(address,address,uint256,uint256):(((address,address,address,address,address,address,address[]),(uint8,uint8,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool,bool,bool))[])",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(start),
        ethereum.Value.fromUnsignedBigInt(end)
      ]
    );

    return result[0].toTupleArray<Reader__getAccountOrdersResultValue0Struct>();
  }

  try_getAccountOrders(
    dataStore: Address,
    account: Address,
    start: BigInt,
    end: BigInt
  ): ethereum.CallResult<Array<Reader__getAccountOrdersResultValue0Struct>> {
    let result = super.tryCall(
      "getAccountOrders",
      "getAccountOrders(address,address,uint256,uint256):(((address,address,address,address,address,address,address[]),(uint8,uint8,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool,bool,bool))[])",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(start),
        ethereum.Value.fromUnsignedBigInt(end)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<Reader__getAccountOrdersResultValue0Struct>()
    );
  }

  getAccountPositionInfoList(
    dataStore: Address,
    referralStorage: Address,
    positionKeys: Array<Bytes>,
    prices: Array<Reader__getAccountPositionInfoListInputPricesStruct>,
    uiFeeReceiver: Address
  ): Array<Reader__getAccountPositionInfoListResultValue0Struct> {
    let result = super.call(
      "getAccountPositionInfoList",
      "getAccountPositionInfoList(address,address,bytes32[],((uint256,uint256),(uint256,uint256),(uint256,uint256))[],address):((((address,address,address),(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool)),((bytes32,address,address,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256),(address,uint256,uint256),(uint256,uint256),uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(int256,uint256,uint256),int256,int256,int256)[])",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(referralStorage),
        ethereum.Value.fromFixedBytesArray(positionKeys),
        ethereum.Value.fromTupleArray(prices),
        ethereum.Value.fromAddress(uiFeeReceiver)
      ]
    );

    return result[0].toTupleArray<
      Reader__getAccountPositionInfoListResultValue0Struct
    >();
  }

  try_getAccountPositionInfoList(
    dataStore: Address,
    referralStorage: Address,
    positionKeys: Array<Bytes>,
    prices: Array<Reader__getAccountPositionInfoListInputPricesStruct>,
    uiFeeReceiver: Address
  ): ethereum.CallResult<
    Array<Reader__getAccountPositionInfoListResultValue0Struct>
  > {
    let result = super.tryCall(
      "getAccountPositionInfoList",
      "getAccountPositionInfoList(address,address,bytes32[],((uint256,uint256),(uint256,uint256),(uint256,uint256))[],address):((((address,address,address),(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool)),((bytes32,address,address,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256),(address,uint256,uint256),(uint256,uint256),uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(int256,uint256,uint256),int256,int256,int256)[])",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(referralStorage),
        ethereum.Value.fromFixedBytesArray(positionKeys),
        ethereum.Value.fromTupleArray(prices),
        ethereum.Value.fromAddress(uiFeeReceiver)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<
        Reader__getAccountPositionInfoListResultValue0Struct
      >()
    );
  }

  getAccountPositions(
    dataStore: Address,
    account: Address,
    start: BigInt,
    end: BigInt
  ): Array<Reader__getAccountPositionsResultValue0Struct> {
    let result = super.call(
      "getAccountPositions",
      "getAccountPositions(address,address,uint256,uint256):(((address,address,address),(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool))[])",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(start),
        ethereum.Value.fromUnsignedBigInt(end)
      ]
    );

    return result[0].toTupleArray<
      Reader__getAccountPositionsResultValue0Struct
    >();
  }

  try_getAccountPositions(
    dataStore: Address,
    account: Address,
    start: BigInt,
    end: BigInt
  ): ethereum.CallResult<Array<Reader__getAccountPositionsResultValue0Struct>> {
    let result = super.tryCall(
      "getAccountPositions",
      "getAccountPositions(address,address,uint256,uint256):(((address,address,address),(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool))[])",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromUnsignedBigInt(start),
        ethereum.Value.fromUnsignedBigInt(end)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<Reader__getAccountPositionsResultValue0Struct>()
    );
  }

  getAdlState(
    dataStore: Address,
    market: Address,
    isLong: boolean,
    prices: Reader__getAdlStateInputPricesStruct
  ): Reader__getAdlStateResult {
    let result = super.call(
      "getAdlState",
      "getAdlState(address,address,bool,((uint256,uint256),(uint256,uint256),(uint256,uint256))):(uint256,bool,int256,uint256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(market),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromTuple(prices)
      ]
    );

    return new Reader__getAdlStateResult(
      result[0].toBigInt(),
      result[1].toBoolean(),
      result[2].toBigInt(),
      result[3].toBigInt()
    );
  }

  try_getAdlState(
    dataStore: Address,
    market: Address,
    isLong: boolean,
    prices: Reader__getAdlStateInputPricesStruct
  ): ethereum.CallResult<Reader__getAdlStateResult> {
    let result = super.tryCall(
      "getAdlState",
      "getAdlState(address,address,bool,((uint256,uint256),(uint256,uint256),(uint256,uint256))):(uint256,bool,int256,uint256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(market),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromTuple(prices)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Reader__getAdlStateResult(
        value[0].toBigInt(),
        value[1].toBoolean(),
        value[2].toBigInt(),
        value[3].toBigInt()
      )
    );
  }

  getDeposit(
    dataStore: Address,
    key: Bytes
  ): Reader__getDepositResultValue0Struct {
    let result = super.call(
      "getDeposit",
      "getDeposit(address,bytes32):(((address,address,address,address,address,address,address,address[],address[]),(uint256,uint256,uint256,uint256,uint256,uint256),(bool)))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromFixedBytes(key)
      ]
    );

    return result[0].toTuple() as Reader__getDepositResultValue0Struct;
  }

  try_getDeposit(
    dataStore: Address,
    key: Bytes
  ): ethereum.CallResult<Reader__getDepositResultValue0Struct> {
    let result = super.tryCall(
      "getDeposit",
      "getDeposit(address,bytes32):(((address,address,address,address,address,address,address,address[],address[]),(uint256,uint256,uint256,uint256,uint256,uint256),(bool)))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromFixedBytes(key)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as Reader__getDepositResultValue0Struct
    );
  }

  getDepositAmountOut(
    dataStore: Address,
    market: Reader__getDepositAmountOutInputMarketStruct,
    prices: Reader__getDepositAmountOutInputPricesStruct,
    longTokenAmount: BigInt,
    shortTokenAmount: BigInt,
    uiFeeReceiver: Address
  ): BigInt {
    let result = super.call(
      "getDepositAmountOut",
      "getDepositAmountOut(address,(address,address,address,address),((uint256,uint256),(uint256,uint256),(uint256,uint256)),uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromUnsignedBigInt(longTokenAmount),
        ethereum.Value.fromUnsignedBigInt(shortTokenAmount),
        ethereum.Value.fromAddress(uiFeeReceiver)
      ]
    );

    return result[0].toBigInt();
  }

  try_getDepositAmountOut(
    dataStore: Address,
    market: Reader__getDepositAmountOutInputMarketStruct,
    prices: Reader__getDepositAmountOutInputPricesStruct,
    longTokenAmount: BigInt,
    shortTokenAmount: BigInt,
    uiFeeReceiver: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getDepositAmountOut",
      "getDepositAmountOut(address,(address,address,address,address),((uint256,uint256),(uint256,uint256),(uint256,uint256)),uint256,uint256,address):(uint256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromUnsignedBigInt(longTokenAmount),
        ethereum.Value.fromUnsignedBigInt(shortTokenAmount),
        ethereum.Value.fromAddress(uiFeeReceiver)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getExecutionPrice(
    dataStore: Address,
    marketKey: Address,
    indexTokenPrice: Reader__getExecutionPriceInputIndexTokenPriceStruct,
    positionSizeInUsd: BigInt,
    positionSizeInTokens: BigInt,
    sizeDeltaUsd: BigInt,
    isLong: boolean
  ): Reader__getExecutionPriceResultValue0Struct {
    let result = super.call(
      "getExecutionPrice",
      "getExecutionPrice(address,address,(uint256,uint256),uint256,uint256,int256,bool):((int256,uint256,uint256))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(marketKey),
        ethereum.Value.fromTuple(indexTokenPrice),
        ethereum.Value.fromUnsignedBigInt(positionSizeInUsd),
        ethereum.Value.fromUnsignedBigInt(positionSizeInTokens),
        ethereum.Value.fromSignedBigInt(sizeDeltaUsd),
        ethereum.Value.fromBoolean(isLong)
      ]
    );

    return result[0].toTuple() as Reader__getExecutionPriceResultValue0Struct;
  }

  try_getExecutionPrice(
    dataStore: Address,
    marketKey: Address,
    indexTokenPrice: Reader__getExecutionPriceInputIndexTokenPriceStruct,
    positionSizeInUsd: BigInt,
    positionSizeInTokens: BigInt,
    sizeDeltaUsd: BigInt,
    isLong: boolean
  ): ethereum.CallResult<Reader__getExecutionPriceResultValue0Struct> {
    let result = super.tryCall(
      "getExecutionPrice",
      "getExecutionPrice(address,address,(uint256,uint256),uint256,uint256,int256,bool):((int256,uint256,uint256))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(marketKey),
        ethereum.Value.fromTuple(indexTokenPrice),
        ethereum.Value.fromUnsignedBigInt(positionSizeInUsd),
        ethereum.Value.fromUnsignedBigInt(positionSizeInTokens),
        ethereum.Value.fromSignedBigInt(sizeDeltaUsd),
        ethereum.Value.fromBoolean(isLong)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as Reader__getExecutionPriceResultValue0Struct
    );
  }

  getMarket(
    dataStore: Address,
    key: Address
  ): Reader__getMarketResultValue0Struct {
    let result = super.call(
      "getMarket",
      "getMarket(address,address):((address,address,address,address))",
      [ethereum.Value.fromAddress(dataStore), ethereum.Value.fromAddress(key)]
    );

    return result[0].toTuple() as Reader__getMarketResultValue0Struct;
  }

  try_getMarket(
    dataStore: Address,
    key: Address
  ): ethereum.CallResult<Reader__getMarketResultValue0Struct> {
    let result = super.tryCall(
      "getMarket",
      "getMarket(address,address):((address,address,address,address))",
      [ethereum.Value.fromAddress(dataStore), ethereum.Value.fromAddress(key)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as Reader__getMarketResultValue0Struct
    );
  }

  getMarketBySalt(
    dataStore: Address,
    salt: Bytes
  ): Reader__getMarketBySaltResultValue0Struct {
    let result = super.call(
      "getMarketBySalt",
      "getMarketBySalt(address,bytes32):((address,address,address,address))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromFixedBytes(salt)
      ]
    );

    return result[0].toTuple() as Reader__getMarketBySaltResultValue0Struct;
  }

  try_getMarketBySalt(
    dataStore: Address,
    salt: Bytes
  ): ethereum.CallResult<Reader__getMarketBySaltResultValue0Struct> {
    let result = super.tryCall(
      "getMarketBySalt",
      "getMarketBySalt(address,bytes32):((address,address,address,address))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromFixedBytes(salt)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as Reader__getMarketBySaltResultValue0Struct
    );
  }

  getMarketInfo(
    dataStore: Address,
    prices: Reader__getMarketInfoInputPricesStruct,
    marketKey: Address
  ): Reader__getMarketInfoResultValue0Struct {
    let result = super.call(
      "getMarketInfo",
      "getMarketInfo(address,((uint256,uint256),(uint256,uint256),(uint256,uint256)),address):(((address,address,address,address),uint256,uint256,(((uint256,uint256),(uint256,uint256)),((uint256,uint256),(uint256,uint256))),(bool,uint256,int256,((uint256,uint256),(uint256,uint256)),((uint256,uint256),(uint256,uint256))),(uint256,uint256,int256),bool))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromAddress(marketKey)
      ]
    );

    return result[0].toTuple() as Reader__getMarketInfoResultValue0Struct;
  }

  try_getMarketInfo(
    dataStore: Address,
    prices: Reader__getMarketInfoInputPricesStruct,
    marketKey: Address
  ): ethereum.CallResult<Reader__getMarketInfoResultValue0Struct> {
    let result = super.tryCall(
      "getMarketInfo",
      "getMarketInfo(address,((uint256,uint256),(uint256,uint256),(uint256,uint256)),address):(((address,address,address,address),uint256,uint256,(((uint256,uint256),(uint256,uint256)),((uint256,uint256),(uint256,uint256))),(bool,uint256,int256,((uint256,uint256),(uint256,uint256)),((uint256,uint256),(uint256,uint256))),(uint256,uint256,int256),bool))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromAddress(marketKey)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as Reader__getMarketInfoResultValue0Struct
    );
  }

  getMarketInfoList(
    dataStore: Address,
    marketPricesList: Array<
      Reader__getMarketInfoListInputMarketPricesListStruct
    >,
    start: BigInt,
    end: BigInt
  ): Array<Reader__getMarketInfoListResultValue0Struct> {
    let result = super.call(
      "getMarketInfoList",
      "getMarketInfoList(address,((uint256,uint256),(uint256,uint256),(uint256,uint256))[],uint256,uint256):(((address,address,address,address),uint256,uint256,(((uint256,uint256),(uint256,uint256)),((uint256,uint256),(uint256,uint256))),(bool,uint256,int256,((uint256,uint256),(uint256,uint256)),((uint256,uint256),(uint256,uint256))),(uint256,uint256,int256),bool)[])",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTupleArray(marketPricesList),
        ethereum.Value.fromUnsignedBigInt(start),
        ethereum.Value.fromUnsignedBigInt(end)
      ]
    );

    return result[0].toTupleArray<
      Reader__getMarketInfoListResultValue0Struct
    >();
  }

  try_getMarketInfoList(
    dataStore: Address,
    marketPricesList: Array<
      Reader__getMarketInfoListInputMarketPricesListStruct
    >,
    start: BigInt,
    end: BigInt
  ): ethereum.CallResult<Array<Reader__getMarketInfoListResultValue0Struct>> {
    let result = super.tryCall(
      "getMarketInfoList",
      "getMarketInfoList(address,((uint256,uint256),(uint256,uint256),(uint256,uint256))[],uint256,uint256):(((address,address,address,address),uint256,uint256,(((uint256,uint256),(uint256,uint256)),((uint256,uint256),(uint256,uint256))),(bool,uint256,int256,((uint256,uint256),(uint256,uint256)),((uint256,uint256),(uint256,uint256))),(uint256,uint256,int256),bool)[])",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTupleArray(marketPricesList),
        ethereum.Value.fromUnsignedBigInt(start),
        ethereum.Value.fromUnsignedBigInt(end)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<Reader__getMarketInfoListResultValue0Struct>()
    );
  }

  getMarketTokenPrice(
    dataStore: Address,
    market: Reader__getMarketTokenPriceInputMarketStruct,
    indexTokenPrice: Reader__getMarketTokenPriceInputIndexTokenPriceStruct,
    longTokenPrice: Reader__getMarketTokenPriceInputLongTokenPriceStruct,
    shortTokenPrice: Reader__getMarketTokenPriceInputShortTokenPriceStruct,
    pnlFactorType: Bytes,
    maximize: boolean
  ): Reader__getMarketTokenPriceResult {
    let result = super.call(
      "getMarketTokenPrice",
      "getMarketTokenPrice(address,(address,address,address,address),(uint256,uint256),(uint256,uint256),(uint256,uint256),bytes32,bool):(int256,(int256,int256,int256,int256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(indexTokenPrice),
        ethereum.Value.fromTuple(longTokenPrice),
        ethereum.Value.fromTuple(shortTokenPrice),
        ethereum.Value.fromFixedBytes(pnlFactorType),
        ethereum.Value.fromBoolean(maximize)
      ]
    );

    return new Reader__getMarketTokenPriceResult(
      result[0].toBigInt(),
      result[1].toTuple() as Reader__getMarketTokenPriceResultValue1Struct
    );
  }

  try_getMarketTokenPrice(
    dataStore: Address,
    market: Reader__getMarketTokenPriceInputMarketStruct,
    indexTokenPrice: Reader__getMarketTokenPriceInputIndexTokenPriceStruct,
    longTokenPrice: Reader__getMarketTokenPriceInputLongTokenPriceStruct,
    shortTokenPrice: Reader__getMarketTokenPriceInputShortTokenPriceStruct,
    pnlFactorType: Bytes,
    maximize: boolean
  ): ethereum.CallResult<Reader__getMarketTokenPriceResult> {
    let result = super.tryCall(
      "getMarketTokenPrice",
      "getMarketTokenPrice(address,(address,address,address,address),(uint256,uint256),(uint256,uint256),(uint256,uint256),bytes32,bool):(int256,(int256,int256,int256,int256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(indexTokenPrice),
        ethereum.Value.fromTuple(longTokenPrice),
        ethereum.Value.fromTuple(shortTokenPrice),
        ethereum.Value.fromFixedBytes(pnlFactorType),
        ethereum.Value.fromBoolean(maximize)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Reader__getMarketTokenPriceResult(
        value[0].toBigInt(),
        value[1].toTuple() as Reader__getMarketTokenPriceResultValue1Struct
      )
    );
  }

  getMarkets(
    dataStore: Address,
    start: BigInt,
    end: BigInt
  ): Array<Reader__getMarketsResultValue0Struct> {
    let result = super.call(
      "getMarkets",
      "getMarkets(address,uint256,uint256):((address,address,address,address)[])",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromUnsignedBigInt(start),
        ethereum.Value.fromUnsignedBigInt(end)
      ]
    );

    return result[0].toTupleArray<Reader__getMarketsResultValue0Struct>();
  }

  try_getMarkets(
    dataStore: Address,
    start: BigInt,
    end: BigInt
  ): ethereum.CallResult<Array<Reader__getMarketsResultValue0Struct>> {
    let result = super.tryCall(
      "getMarkets",
      "getMarkets(address,uint256,uint256):((address,address,address,address)[])",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromUnsignedBigInt(start),
        ethereum.Value.fromUnsignedBigInt(end)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<Reader__getMarketsResultValue0Struct>()
    );
  }

  getNetPnl(
    dataStore: Address,
    market: Reader__getNetPnlInputMarketStruct,
    indexTokenPrice: Reader__getNetPnlInputIndexTokenPriceStruct,
    maximize: boolean
  ): BigInt {
    let result = super.call(
      "getNetPnl",
      "getNetPnl(address,(address,address,address,address),(uint256,uint256),bool):(int256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(indexTokenPrice),
        ethereum.Value.fromBoolean(maximize)
      ]
    );

    return result[0].toBigInt();
  }

  try_getNetPnl(
    dataStore: Address,
    market: Reader__getNetPnlInputMarketStruct,
    indexTokenPrice: Reader__getNetPnlInputIndexTokenPriceStruct,
    maximize: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getNetPnl",
      "getNetPnl(address,(address,address,address,address),(uint256,uint256),bool):(int256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(indexTokenPrice),
        ethereum.Value.fromBoolean(maximize)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getOpenInterestWithPnl(
    dataStore: Address,
    market: Reader__getOpenInterestWithPnlInputMarketStruct,
    indexTokenPrice: Reader__getOpenInterestWithPnlInputIndexTokenPriceStruct,
    isLong: boolean,
    maximize: boolean
  ): BigInt {
    let result = super.call(
      "getOpenInterestWithPnl",
      "getOpenInterestWithPnl(address,(address,address,address,address),(uint256,uint256),bool,bool):(int256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(indexTokenPrice),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromBoolean(maximize)
      ]
    );

    return result[0].toBigInt();
  }

  try_getOpenInterestWithPnl(
    dataStore: Address,
    market: Reader__getOpenInterestWithPnlInputMarketStruct,
    indexTokenPrice: Reader__getOpenInterestWithPnlInputIndexTokenPriceStruct,
    isLong: boolean,
    maximize: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getOpenInterestWithPnl",
      "getOpenInterestWithPnl(address,(address,address,address,address),(uint256,uint256),bool,bool):(int256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(indexTokenPrice),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromBoolean(maximize)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getOrder(dataStore: Address, key: Bytes): Reader__getOrderResultValue0Struct {
    let result = super.call(
      "getOrder",
      "getOrder(address,bytes32):(((address,address,address,address,address,address,address[]),(uint8,uint8,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool,bool,bool)))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromFixedBytes(key)
      ]
    );

    return result[0].toTuple() as Reader__getOrderResultValue0Struct;
  }

  try_getOrder(
    dataStore: Address,
    key: Bytes
  ): ethereum.CallResult<Reader__getOrderResultValue0Struct> {
    let result = super.tryCall(
      "getOrder",
      "getOrder(address,bytes32):(((address,address,address,address,address,address,address[]),(uint8,uint8,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool,bool,bool)))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromFixedBytes(key)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as Reader__getOrderResultValue0Struct
    );
  }

  getPnl(
    dataStore: Address,
    market: Reader__getPnlInputMarketStruct,
    indexTokenPrice: Reader__getPnlInputIndexTokenPriceStruct,
    isLong: boolean,
    maximize: boolean
  ): BigInt {
    let result = super.call(
      "getPnl",
      "getPnl(address,(address,address,address,address),(uint256,uint256),bool,bool):(int256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(indexTokenPrice),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromBoolean(maximize)
      ]
    );

    return result[0].toBigInt();
  }

  try_getPnl(
    dataStore: Address,
    market: Reader__getPnlInputMarketStruct,
    indexTokenPrice: Reader__getPnlInputIndexTokenPriceStruct,
    isLong: boolean,
    maximize: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPnl",
      "getPnl(address,(address,address,address,address),(uint256,uint256),bool,bool):(int256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(indexTokenPrice),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromBoolean(maximize)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPnlToPoolFactor(
    dataStore: Address,
    marketAddress: Address,
    prices: Reader__getPnlToPoolFactorInputPricesStruct,
    isLong: boolean,
    maximize: boolean
  ): BigInt {
    let result = super.call(
      "getPnlToPoolFactor",
      "getPnlToPoolFactor(address,address,((uint256,uint256),(uint256,uint256),(uint256,uint256)),bool,bool):(int256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(marketAddress),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromBoolean(maximize)
      ]
    );

    return result[0].toBigInt();
  }

  try_getPnlToPoolFactor(
    dataStore: Address,
    marketAddress: Address,
    prices: Reader__getPnlToPoolFactorInputPricesStruct,
    isLong: boolean,
    maximize: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPnlToPoolFactor",
      "getPnlToPoolFactor(address,address,((uint256,uint256),(uint256,uint256),(uint256,uint256)),bool,bool):(int256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(marketAddress),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromBoolean(maximize)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPosition(
    dataStore: Address,
    key: Bytes
  ): Reader__getPositionResultValue0Struct {
    let result = super.call(
      "getPosition",
      "getPosition(address,bytes32):(((address,address,address),(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool)))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromFixedBytes(key)
      ]
    );

    return result[0].toTuple() as Reader__getPositionResultValue0Struct;
  }

  try_getPosition(
    dataStore: Address,
    key: Bytes
  ): ethereum.CallResult<Reader__getPositionResultValue0Struct> {
    let result = super.tryCall(
      "getPosition",
      "getPosition(address,bytes32):(((address,address,address),(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool)))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromFixedBytes(key)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as Reader__getPositionResultValue0Struct
    );
  }

  getPositionInfo(
    dataStore: Address,
    referralStorage: Address,
    positionKey: Bytes,
    prices: Reader__getPositionInfoInputPricesStruct,
    sizeDeltaUsd: BigInt,
    uiFeeReceiver: Address,
    usePositionSizeAsSizeDeltaUsd: boolean
  ): Reader__getPositionInfoResultValue0Struct {
    let result = super.call(
      "getPositionInfo",
      "getPositionInfo(address,address,bytes32,((uint256,uint256),(uint256,uint256),(uint256,uint256)),uint256,address,bool):((((address,address,address),(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool)),((bytes32,address,address,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256),(address,uint256,uint256),(uint256,uint256),uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(int256,uint256,uint256),int256,int256,int256))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(referralStorage),
        ethereum.Value.fromFixedBytes(positionKey),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromUnsignedBigInt(sizeDeltaUsd),
        ethereum.Value.fromAddress(uiFeeReceiver),
        ethereum.Value.fromBoolean(usePositionSizeAsSizeDeltaUsd)
      ]
    );

    return result[0].toTuple() as Reader__getPositionInfoResultValue0Struct;
  }

  try_getPositionInfo(
    dataStore: Address,
    referralStorage: Address,
    positionKey: Bytes,
    prices: Reader__getPositionInfoInputPricesStruct,
    sizeDeltaUsd: BigInt,
    uiFeeReceiver: Address,
    usePositionSizeAsSizeDeltaUsd: boolean
  ): ethereum.CallResult<Reader__getPositionInfoResultValue0Struct> {
    let result = super.tryCall(
      "getPositionInfo",
      "getPositionInfo(address,address,bytes32,((uint256,uint256),(uint256,uint256),(uint256,uint256)),uint256,address,bool):((((address,address,address),(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(bool)),((bytes32,address,address,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256,uint256,uint256),(uint256,uint256,uint256,uint256),(address,uint256,uint256),(uint256,uint256),uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),(int256,uint256,uint256),int256,int256,int256))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(referralStorage),
        ethereum.Value.fromFixedBytes(positionKey),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromUnsignedBigInt(sizeDeltaUsd),
        ethereum.Value.fromAddress(uiFeeReceiver),
        ethereum.Value.fromBoolean(usePositionSizeAsSizeDeltaUsd)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as Reader__getPositionInfoResultValue0Struct
    );
  }

  getPositionPnlUsd(
    dataStore: Address,
    market: Reader__getPositionPnlUsdInputMarketStruct,
    prices: Reader__getPositionPnlUsdInputPricesStruct,
    positionKey: Bytes,
    sizeDeltaUsd: BigInt
  ): Reader__getPositionPnlUsdResult {
    let result = super.call(
      "getPositionPnlUsd",
      "getPositionPnlUsd(address,(address,address,address,address),((uint256,uint256),(uint256,uint256),(uint256,uint256)),bytes32,uint256):(int256,int256,uint256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromFixedBytes(positionKey),
        ethereum.Value.fromUnsignedBigInt(sizeDeltaUsd)
      ]
    );

    return new Reader__getPositionPnlUsdResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_getPositionPnlUsd(
    dataStore: Address,
    market: Reader__getPositionPnlUsdInputMarketStruct,
    prices: Reader__getPositionPnlUsdInputPricesStruct,
    positionKey: Bytes,
    sizeDeltaUsd: BigInt
  ): ethereum.CallResult<Reader__getPositionPnlUsdResult> {
    let result = super.tryCall(
      "getPositionPnlUsd",
      "getPositionPnlUsd(address,(address,address,address,address),((uint256,uint256),(uint256,uint256),(uint256,uint256)),bytes32,uint256):(int256,int256,uint256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromFixedBytes(positionKey),
        ethereum.Value.fromUnsignedBigInt(sizeDeltaUsd)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Reader__getPositionPnlUsdResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  getSwapAmountOut(
    dataStore: Address,
    market: Reader__getSwapAmountOutInputMarketStruct,
    prices: Reader__getSwapAmountOutInputPricesStruct,
    tokenIn: Address,
    amountIn: BigInt,
    uiFeeReceiver: Address
  ): Reader__getSwapAmountOutResult {
    let result = super.call(
      "getSwapAmountOut",
      "getSwapAmountOut(address,(address,address,address,address),((uint256,uint256),(uint256,uint256),(uint256,uint256)),address,uint256,address):(uint256,int256,(uint256,uint256,uint256,address,uint256,uint256))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromAddress(tokenIn),
        ethereum.Value.fromUnsignedBigInt(amountIn),
        ethereum.Value.fromAddress(uiFeeReceiver)
      ]
    );

    return new Reader__getSwapAmountOutResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toTuple() as Reader__getSwapAmountOutResultFeesStruct
    );
  }

  try_getSwapAmountOut(
    dataStore: Address,
    market: Reader__getSwapAmountOutInputMarketStruct,
    prices: Reader__getSwapAmountOutInputPricesStruct,
    tokenIn: Address,
    amountIn: BigInt,
    uiFeeReceiver: Address
  ): ethereum.CallResult<Reader__getSwapAmountOutResult> {
    let result = super.tryCall(
      "getSwapAmountOut",
      "getSwapAmountOut(address,(address,address,address,address),((uint256,uint256),(uint256,uint256),(uint256,uint256)),address,uint256,address):(uint256,int256,(uint256,uint256,uint256,address,uint256,uint256))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromAddress(tokenIn),
        ethereum.Value.fromUnsignedBigInt(amountIn),
        ethereum.Value.fromAddress(uiFeeReceiver)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Reader__getSwapAmountOutResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toTuple() as Reader__getSwapAmountOutResultFeesStruct
      )
    );
  }

  getSwapPriceImpact(
    dataStore: Address,
    marketKey: Address,
    tokenIn: Address,
    tokenOut: Address,
    amountIn: BigInt,
    tokenInPrice: Reader__getSwapPriceImpactInputTokenInPriceStruct,
    tokenOutPrice: Reader__getSwapPriceImpactInputTokenOutPriceStruct
  ): Reader__getSwapPriceImpactResult {
    let result = super.call(
      "getSwapPriceImpact",
      "getSwapPriceImpact(address,address,address,address,uint256,(uint256,uint256),(uint256,uint256)):(int256,int256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(marketKey),
        ethereum.Value.fromAddress(tokenIn),
        ethereum.Value.fromAddress(tokenOut),
        ethereum.Value.fromUnsignedBigInt(amountIn),
        ethereum.Value.fromTuple(tokenInPrice),
        ethereum.Value.fromTuple(tokenOutPrice)
      ]
    );

    return new Reader__getSwapPriceImpactResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getSwapPriceImpact(
    dataStore: Address,
    marketKey: Address,
    tokenIn: Address,
    tokenOut: Address,
    amountIn: BigInt,
    tokenInPrice: Reader__getSwapPriceImpactInputTokenInPriceStruct,
    tokenOutPrice: Reader__getSwapPriceImpactInputTokenOutPriceStruct
  ): ethereum.CallResult<Reader__getSwapPriceImpactResult> {
    let result = super.tryCall(
      "getSwapPriceImpact",
      "getSwapPriceImpact(address,address,address,address,uint256,(uint256,uint256),(uint256,uint256)):(int256,int256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromAddress(marketKey),
        ethereum.Value.fromAddress(tokenIn),
        ethereum.Value.fromAddress(tokenOut),
        ethereum.Value.fromUnsignedBigInt(amountIn),
        ethereum.Value.fromTuple(tokenInPrice),
        ethereum.Value.fromTuple(tokenOutPrice)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Reader__getSwapPriceImpactResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  getWithdrawal(
    dataStore: Address,
    key: Bytes
  ): Reader__getWithdrawalResultValue0Struct {
    let result = super.call(
      "getWithdrawal",
      "getWithdrawal(address,bytes32):(((address,address,address,address,address,address[],address[]),(uint256,uint256,uint256,uint256,uint256,uint256),(bool)))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromFixedBytes(key)
      ]
    );

    return result[0].toTuple() as Reader__getWithdrawalResultValue0Struct;
  }

  try_getWithdrawal(
    dataStore: Address,
    key: Bytes
  ): ethereum.CallResult<Reader__getWithdrawalResultValue0Struct> {
    let result = super.tryCall(
      "getWithdrawal",
      "getWithdrawal(address,bytes32):(((address,address,address,address,address,address[],address[]),(uint256,uint256,uint256,uint256,uint256,uint256),(bool)))",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromFixedBytes(key)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as Reader__getWithdrawalResultValue0Struct
    );
  }

  getWithdrawalAmountOut(
    dataStore: Address,
    market: Reader__getWithdrawalAmountOutInputMarketStruct,
    prices: Reader__getWithdrawalAmountOutInputPricesStruct,
    marketTokenAmount: BigInt,
    uiFeeReceiver: Address
  ): Reader__getWithdrawalAmountOutResult {
    let result = super.call(
      "getWithdrawalAmountOut",
      "getWithdrawalAmountOut(address,(address,address,address,address),((uint256,uint256),(uint256,uint256),(uint256,uint256)),uint256,address):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromUnsignedBigInt(marketTokenAmount),
        ethereum.Value.fromAddress(uiFeeReceiver)
      ]
    );

    return new Reader__getWithdrawalAmountOutResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getWithdrawalAmountOut(
    dataStore: Address,
    market: Reader__getWithdrawalAmountOutInputMarketStruct,
    prices: Reader__getWithdrawalAmountOutInputPricesStruct,
    marketTokenAmount: BigInt,
    uiFeeReceiver: Address
  ): ethereum.CallResult<Reader__getWithdrawalAmountOutResult> {
    let result = super.tryCall(
      "getWithdrawalAmountOut",
      "getWithdrawalAmountOut(address,(address,address,address,address),((uint256,uint256),(uint256,uint256),(uint256,uint256)),uint256,address):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(dataStore),
        ethereum.Value.fromTuple(market),
        ethereum.Value.fromTuple(prices),
        ethereum.Value.fromUnsignedBigInt(marketTokenAmount),
        ethereum.Value.fromAddress(uiFeeReceiver)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Reader__getWithdrawalAmountOutResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }
}
